from __future__ import division
from pyproj import Proj
import pickle
import ConfigParser
import numpy as np
import xlrd
import pandas as pd
import fiona
from math import floor
from shapely.geometry import MultiPoint
from shapely.ops import cascaded_union
import shapely
from datetime import timedelta
from operator import itemgetter
import platform
from copy import deepcopy
from sklearn.cluster import KMeans
import os


def ConfigSectionMap(Config, section):
    dict1 = {}
    options = Config.options(section)
    for option in options:
        try:
            dict1[option] = Config.get(section, option)
            if dict1[option] == -1:
                DebugPrint("skip: %s" % option)
        except:
            print("exception on %s!" % option)
            dict1[option] = None
    return dict1

Config = ConfigParser.ConfigParser()
if 'Linux' in platform.platform():
    Config.read("paramsLinux.conf")
else:
    Config.read("params.conf")

def setupData(hierObj):

    setupGridStructure(hierObj)
    # get weather data
    getWeatherData(hierObj)
    getWeatherProbability(hierObj,2014,hierObj.startTime,hierObj.endTime)
    #data is only needed if we are re-running prediction or clustering
    #if only simulator is running, this can be skipped

    hierObj.eventTimes, eventTimesComplete = getTrafficData(hierObj)
    hierObj.eventTimesComplete = eventTimesComplete
    #store in pandas data frame format
    hierObj.eventTimesDF = pd.DataFrame(hierObj.eventTimes, columns=["x", "y", "time", "coordX", "coordY",
                                                                     "severity", "rain", "snow", "season1",
                                                                     "season2", "season3", "season4",
                                                                     "timeSlot1", "timeSlot2", "timeSlot3",
                                                                     "timeSlot4", "timeSlot5", "timeSlot6",
                                                                     "weekday"])

    hierObj.eventTimesCompleteDF = pd.DataFrame(eventTimesComplete,
                                                columns=["x", "y", "time", "coordX", "coordY",
                                                         "severity", "rain", "snow", "season1",
                                                         "season2", "season3", "season4",
                                                         "timeSlot1", "timeSlot2", "timeSlot3",
                                                         "timeSlot4", "timeSlot5", "timeSlot6",
                                                         "weekday"])

    interArrivalTimes = getInterArrivalTimes(hierObj,"train")
    hierObj.survRows = getEventDynamicFeatures(interArrivalTimes,hierObj,"train")

    interArrivalTimes = getInterArrivalTimes(hierObj,"test")
    hierObj.survRowsTestSet = getEventDynamicFeatures(interArrivalTimes,hierObj,"test")

    getGridStaticFeatures(hierObj)
    hierObj.rangeX, hierObj.rangeY = hierObj.grids.shape

    hierObj.spatialFeatures = getSpatialFeatures(hierObj)

    #create list of column names used in the data set
    hierObj.columnNamesFire = ["gridNumber", "interArrival", "death", "rain", "snow", "season", "timeZone", "weekend",
                               "pastGrid2", "pastGrid7", "pastGrid30", "pastNeighbor2", "pastNeighbor7",
                               "pastNeighbor30"]

def setupGridStructure(hierObj):
    hierObj.gridSize = 1609.34
    shpFilePath = (str(ConfigSectionMap(Config, "filePaths")["shpfile"]))
    fshp = fiona.open(shpFilePath)
    bounds = fshp.bounds
    print(bounds)
    hierObj.xLow = bounds[0]
    hierObj.xHigh = bounds[2]
    hierObj.yLow = bounds[1]
    hierObj.yHigh = bounds[3]
    hierObj.grids = np.load(ConfigSectionMap(Config, "filePaths")["grids"])
    #setup grid and coordinate data structure needed for the operation
    hierObj.numGrids = len(hierObj.grids) * len(hierObj.grids[0])
    streetIntersectionsPath = ConfigSectionMap(Config, "filePaths")["streetintersectionspath"]
    hierObj.intersectionsByGrid = pickle.load(
        open(streetIntersectionsPath, 'rb'))  # generated by parseOpenStreetResults in project OpenStreetMaps
    # setup reverse coordinates : gridNum --> grid center coordinates
    hierObj.reverseCoordinate = {}
    # setup reverse grid Numbers : gridNum --> gridx, grid y
    hierObj.reverseGrid = {}
    for counterY in range(len(hierObj.grids)):
        for counterX in range(len(hierObj.grids)):
            gridNum = counterY * len(hierObj.grids) + counterX
            hierObj.reverseCoordinate[gridNum] = (hierObj.grids[counterY][counterX][0] +
                                                  hierObj.grids[counterY][counterX][1]) / float(2)
            hierObj.reverseGrid[gridNum] = [counterX,counterY]

    with open('debugDump/reverseCoords', 'w') as f:
        pickle.dump(hierObj.reverseCoordinate, f)

    #get valid grids
    hierObj.validGrids = getValidGrids(hierObj)

    #setup a reverse dictionary:
    if not os.path.isfile("data/gridToCoord.pickle"):
        numRows = 30
        numColumns = 30
        gridPlacements = np.zeros((numRows,numColumns))
        hierObj.gridToCoord = {}
        gridCounter = 0
        for i in range(numRows):
            for j in range(numColumns):
                gridPlacements[i,j] = gridCounter
                hierObj.gridToCoord[gridCounter] = (i, j)
                gridCounter+=1
        with open(os.getcwd()+"/data/gridToCoord.pickle",'wb') as f:
            pickle.dump(hierObj.gridToCoord,f)

    else:
        with open(os.getcwd()+"/data/gridToCoord.pickle",'rb') as f:
            hierObj.gridToCoord = pickle.load(f)



def getWeatherData(hierObj):
    # get weather data
    hierObj.sheetWeather = {}
    for year in [2014, 2015, 2016]:
        weatherWorkBook = xlrd.open_workbook(
            ConfigSectionMap(Config, "filePaths")["weatherdatapath"] + str(year) + ".xlsx")
        hierObj.sheetWeather[str(year)] = weatherWorkBook.sheet_by_index(0)

def getSpatialFeatures(hierObj):
    pass

def getGridStaticFeatures(hierObj):
    #get Static features
    hierObj.gridStaticFeatures = {}
    for counterY in range(len(hierObj.grids)):
        for counterX in range(len(hierObj.grids)):
            gridNum = counterY * len(hierObj.grids) + counterX
            try:
                mask = (hierObj.eventTimesDF['coordX'] == counterX) & (hierObj.eventTimesDF['coordY'] == counterY)
                tempData = hierObj.eventTimesDF.loc[mask]
                numIncidentsInGrid = len(tempData.values)
            except KeyError:  # intersections are only available for valid grids
                numIntersections = 0
                numIncidentsInGrid = 0
            # gridStaticFeatures[gridNum] = [numIntersections,numIncidentsInGrid]
            hierObj.gridStaticFeatures[gridNum] = [numIncidentsInGrid]

    # create list structure to match with existing code
    hierObj.gridStatic = []
    for counter in range(hierObj.numGrids):
        temp = [counter]
        temp.extend(hierObj.gridStaticFeatures[counter])
        hierObj.gridStatic.append(temp)

def getValidGrids(hierObj):
    validGrids = []
    shpFileWetlandPath = (str(ConfigSectionMap(Config, "filePaths")["shpwetland"]))
    workBookNonResidentialPath = (str(ConfigSectionMap(Config, "filePaths")["workbooknonres"]))

    if not os.path.isfile('data/validGrids.pickle'):

        p1 = Proj(
            '+proj=lcc +lat_1=36.41666666666666 +lat_2=35.25 +lat_0=34.33333333333334 +lon_0=-86 +x_0=600000 +y_0=0 +ellps=GRS80 +datum=NAD83 +no_defs')


        fshpWetLand = fiona.open(shpFileWetlandPath)
        shapesTotal = []
        print("Do union on wetlands")
        for counterShp in range(0, len(fshpWetLand)):
            shapefile_record = fshpWetLand[counterShp]
            shape = shapely.geometry.asShape(shapefile_record['geometry'])
            print("adding shape " + str(counterShp))
            shapesTotal.append(shape)
        print("shapes added. attempt union")
        # shapeComplete = unary_union(shapesTotal)
        #shapeCompleteWetlands = cascaded_union(shapesTotal)
        shapeCompleteWetlands = cascaded_union(shapesTotal)


        # create shape list for parks and other non-residential areas
        workBookNonResidential = xlrd.open_workbook(workBookNonResidentialPath)
        currentSheetNonRes = workBookNonResidential.sheet_by_index(0)
        numRowsNonRes = currentSheetNonRes.nrows
        currRowNonRes = 0
        shapesNonRes = []
        while currRowNonRes < numRowsNonRes:
            pointList = []
            line = currentSheetNonRes.cell_value(currRowNonRes, 0)
            lineList = str(line).split(')')
            for element in lineList:
                try:
                    y = float(element.split(',')[0].split('(')[1])
                    x = float(element.split(',')[1])
                    xStatePlane, yStatePlane = p1(x, y)
                    pointList.append((xStatePlane, yStatePlane))
                except IndexError:
                    print(element)
            shapesNonRes.append(MultiPoint(pointList).convex_hull)
            currRowNonRes += 1
        shapeNonRes = cascaded_union(shapesNonRes)

        shpFilePath = (str(ConfigSectionMap(Config, "filePaths")["shpfile"]))
        shp = fiona.open(shpFilePath)
        cwd = os.getcwd()

        for counterY in range(len(hierObj.grids)):
            for counterX in range(len(hierObj.grids)):
                gridNum = counterY * len(hierObj.grids) + counterX
                gridCentroid = (hierObj.grids[counterY,counterX][0] + hierObj.grids[counterY,counterX][1])/2
                point = shapely.geometry.Point(gridCentroid[0],gridCentroid[1])

                gridInCountyFlag = False
                for counterShape in range(len(shp)):
                    shapefile_record = shp[counterShape]
                    # print str(shapefile_record['properties']['NAMELSAD10'])
                    shape = shapely.geometry.asShape(shapefile_record['geometry'])
                    if shape.contains(point):
                        if shapeCompleteWetlands.contains(point) or shapeNonRes.contains(point):
                            gridInCountyFlag = False
                        else:
                            gridInCountyFlag = True
                        break
                if gridInCountyFlag:
                    validGrids.append(gridNum)
        validGridFile = os.getcwd() + "/data/validGrids.pickle"
        with open(validGridFile,'wb') as f:
            pickle.dump(validGrids,f)
    else:
        validGridFile = os.getcwd() + "/data/validGrids.pickle"
        with open(validGridFile, 'rb') as f:
            validGrids = pickle.load(f)

    return validGrids

def setupResponseStations(hierObj):
    p1 = Proj(
        '+proj=lcc +lat_1=36.41666666666666 +lat_2=35.25 +lat_0=34.33333333333334 +lon_0=-86 +x_0=600000 +y_0=0 +ellps=GRS80 +datum=NAD83 +no_defs')

    fire_station_locations = [[36.2293358, -86.756738], [36.1697414, -86.779294], [36.1866133, -86.7681046],
                              [36.089909, -86.68701], [36.154991, -86.771266], [36.068419, -86.716868],
                              [36.117907, -86.886861], [36.133068, -86.788362], [36.040225, -86.740442],
                              [36.18283, -86.8123991], [36.141278, -86.742412], [36.1530345, -86.8405603],
                              [36.1751649, -86.7420159], [36.124752, -86.697547], [36.129539, -86.802629],
                              [36.130586, -86.835813], [36.196646, -86.7374509], [36.156135, -86.806267],
                              [36.104299, -86.813174], [36.116915, -86.7470419], [36.2166869, -86.6884441],
                              [36.1688266, -86.8618292], [36.20352, -86.8408927], [36.2161199, -86.801137],
                              [36.040249, -86.671728], [36.07818, -86.757934], [36.169679, -86.682828],
                              [36.22417, -86.725624], [36.316548, -86.876178], [36.259073, -86.7159337],
                              [36.2003224, -86.6214049], [36.0674821, -86.630828], [36.092097, -86.983008],
                              [36.052161, -86.59853], [36.264492, -86.648081], [36.07202, -86.9336919],
                              [36.2606255, -86.6846045], [36.2907343, -86.7378586]]
    mhiFireStationIds = [1, 2, 4, 5, 6, 8, 9, 10, 11, 12, 15, 17, 18, 19, 20, 21, 23, 25, 26, 28, 29, 30, 31, 32, 33,
                         35, 37, 39];

    hierObj.stationCoord = {}
    for counter in range(len(mhiFireStationIds)):
        tempCoord = p1(fire_station_locations[counter][1],fire_station_locations[counter][0])
        grid = getGridForCoordinate([tempCoord[0], tempCoord[1]],hierObj.xLow, hierObj.yLow)
        gridNum = grid[1]*len(hierObj.grids) + grid[0]
        hierObj.stationCoord[mhiFireStationIds[counter]] = gridNum

def getGridForCoordinate(coordinate,xLow,yLow):
    gridSize = 1609.34#1 mile to meter
    x = coordinate[0]
    y = coordinate[1]
    gridX = floor((x-xLow)/float(gridSize))
    gridY = floor((y-yLow)/float(gridSize))
    if gridX > 30 or gridY > 30 or gridX < 0 or gridY < 0:
        raise Exception("Error in coordinates {} and {}".format(x,y))
    return gridX,gridY

def read_databaseLocalCopy():
  dbDataFireLocalCopy  = ConfigSectionMap(Config, "filePaths")["datafirelocal"]
  row_list = pickle.load(open(dbDataFireLocalCopy, 'rb'))
  return row_list

def getWeatherProbability(hierObj,year, startDate, endDate):
    #get probability for weather variables, season and timezone in our data
    numRows = hierObj.sheetWeather[str(year)].nrows
    endMonth = endDate.month
    startMonth = startDate.month
    rainVal = []
    tempVal = []
    for counter in range(1,numRows):
        if int(hierObj.sheetWeather[str(year)].cell_value(counter, 0)) <= endMonth and int(
                hierObj.sheetWeather[str(year)].cell_value(counter, 0)) >= startMonth:
            tempVal.append(float(hierObj.sheetWeather[str(year)].cell_value(counter, 2)))
            rainVal.append(float(hierObj.sheetWeather[str(year)].cell_value(counter, 7)))

    numClusters = 3

    hierObj.meanRain = sum(rainVal)/float(len(rainVal))
    hierObj.meanTemp = sum(tempVal)/float(len(tempVal))

    # hierObj.rainCluster = KMeans(n_clusters=numClusters).fit(rainVal)
    # hierObj.tempCluster = KMeans(n_clusters=numClusters).fit(tempVal)


    # hierObj.rainClusterProb = []
    # for cluster in range(numClusters):
    #     hierObj.rainClusterProb.append(len([x for x in hierObj.rainCluster.labels_ if x == cluster])/float(len(hierObj.rainCluster.labels_)))
    #
    # hierObj.tempClusterProb = []
    # for cluster in range(numClusters):
    #     hierObj.tempClusterProb.append(len([x for x in hierObj.tempCluster.labels_ if x == cluster]) / float(len(hierObj.tempCluster.labels_)))
    #
    tempDateTime = startDate
    seasonCounters = deepcopy([0]) * 4
    while tempDateTime < endDate:
        if tempDateTime.month in [1, 2, 12]:
            seasonCounters[0] += 1
        elif tempDateTime.month in [3, 4]:
            seasonCounters[1] += 1
        elif tempDateTime.month in [5, 6, 7, 8, 9]:
            seasonCounters[2] += 1
        elif tempDateTime.month in [10, 11]:
            seasonCounters[3] += 1
        tempDateTime += timedelta(days=1)

    hierObj.seasonProb = [x/float(sum(seasonCounters)) for x in seasonCounters]

    #store the discrete set of values that the features can take
    hierObj.seasonVal = [1,2,3,4]
    hierObj.timeZoneVal = [0,1,2,3,4]
    # hierObj.rainVal = [x[0] for x in hierObj.rainCluster.cluster_centers_]
    # hierObj.tempVal = [x[0] for x in hierObj.tempCluster.cluster_centers_]


def getTemporalFeaturesGivenTime(hierObj,time):
    #"rain", "snow","season1", "season2", "season3", "season4", "timeSlot1", "timeSlot2", "timeSlot3", "timeSlot4", "timeSlot5",
    #"timeSlot6","weekday"
    result = []
    numRows = hierObj.sheetWeather[str(time.year)].nrows
    month = time.month
    day = time.day
    for counter in range(1, numRows):
        if int(hierObj.sheetWeather[str(time.year)].cell_value(counter, 0)) == month and int(
                hierObj.sheetWeather[str(time.year)].cell_value(counter, 1)) == day:
            weather = [float(hierObj.sheetWeather[str(time.year)].cell_value(counter, 2)),
                       float(hierObj.sheetWeather[str(time.year)].cell_value(counter, 7))]
            break
            # get season
    # when set to true, we use one variable each for season and timeZone with levels, when false, we create
    # a vector of values
    #creating columns. Factors need not be taken into account.
    factorR = False
    if factorR:
        if time.month in [1, 2, 12]:
            season = 1
        elif time.month in [3, 4]:
            season = 2
        elif time.month in [5, 6, 7, 8, 9]:
            season = 3
        elif time.month in [10, 11]:
            season = 4
        weather.append(season)

        timeZone = getTimeZoneOfDay(time)
        if time.weekday() in [4, 5, 6]:
            weekend = 1
        else:
            weekend = 0

        result.extend(weather)
        result.append(timeZone)
        result.append(weekend)


    else:
        season = [0] * 4
        if time.month in [1, 2, 12]:
            season[0] = 1
        elif time.month in [3, 4]:
            season[1] = 1
        elif time.month in [5, 6, 7, 8, 9]:
            season[2] = 1
        elif time.month in [10, 11]:
            season[3] = 1
        weather.extend(season)

        # get timezone vector
        timeZone = [0] * 6
        timeZone[getTimeZoneOfDay(time)] = 1

        if time.weekday() in [4, 5, 6]:
            weekend = 1
        else:
            weekend = 0
        result.extend(weather)
        result.extend(timeZone)
        result.append(weekend)

    return result

def getTimeZoneOfDay(currDateTime):
    zone = 0
    # Use if 6 time zones are being used
    if currDateTime.hour < 4:
        zone = 0
    elif currDateTime.hour < 8:
        zone = 1
    elif currDateTime.hour < 12:
        zone = 2
    elif currDateTime.hour < 16:
        zone = 3
    elif currDateTime.hour < 20:
        zone = 4
    elif currDateTime.hour < 24:
        zone = 5
    return zone

def getTrafficData(hierObj):
    #return past crime according to batch number
    p1 = Proj('+proj=lcc +lat_1=36.41666666666666 +lat_2=35.25 +lat_0=34.33333333333334 +lon_0=-86 +x_0=600000 +y_0=0 +ellps=GRS80 +datum=NAD83 +no_defs')
    # dbData = read_database(29, 0, 24)
    dbData = read_databaseLocalCopy()
    print "Total Length of Data is {}".format(len(dbData))

    incidents = []  # includes only the training set
    incidentsComplete = []
    for counter in range(len(dbData)):
        # t1 = datetime.strptime(str(currentSheet.cell_value(rowCounter, 6)[0:14]), "%Y%m%d %H:%M")
        t1 = dbData[counter][2]
        # get x coordinate
        x = dbData[counter][1]
        y = dbData[counter][0]
        x, y = p1(x, y)
        grid = getGridForCoordinate([x, y], hierObj.xLow, hierObj.yLow)
        gridX = int(grid[0])
        gridY = int(grid[1])
        gridNum = gridY * len(hierObj.grids) + gridX
        severity = str(dbData[counter][5])[2]
        if severity not in ['A', 'B', 'C', 'D', 'E', 'F']:
            print dbData[counter]
            print ("******Unexpected Severity******")
        if gridNum in hierObj.validGrids:
            cov = getTemporalFeaturesGivenTime(hierObj, t1)
            temp = [x, y, t1, gridX, gridY, severity]
            temp.extend(cov)
            if hierObj.startTime < t1 < hierObj.endTime:
                incidents.append(temp)
            incidentsComplete.append(temp)
    return incidents, incidentsComplete

def getInterArrivalTimes(hierObj,purpose):
    #returns interarrival times grid wise, without censoring
	#reset times according to requirement if needed
    #set dates in use according to
    if purpose == "test":
        tempStart = hierObj.startTimeTest
        tempEnd = hierObj.endTimeTest
    elif purpose == "train":
        tempStart = hierObj.startTime
        tempEnd = hierObj.endTime

    tempDf = hierObj.eventTimesCompleteDF.loc[(hierObj.eventTimesCompleteDF['time'] > tempStart)
                                      & (hierObj.eventTimesCompleteDF['time'] < tempEnd)]

    sortedDf = tempDf.sort('time')
    tempDictLastIncident = {}
    events = []

    for counterY in range(len(hierObj.grids)):
        for counterX in range(len(hierObj.grids)):
            tempGridNum = counterY*len(hierObj.grids) + counterX
            tempDictLastIncident[tempGridNum] = tempStart

    #iteratively look at each incident:
    for index,row in sortedDf.iterrows():
        try:
            currRow = row
            currGrid = currRow.coordY*len(hierObj.grids) + currRow.coordX
            #calculate time difference
            lastTimeCurrGrid = tempDictLastIncident[currGrid]
            currGridTime = currRow.time
            if int((currGridTime - lastTimeCurrGrid).total_seconds()) == 0:
                print "0 crime time"
            events.append([int((currGridTime - lastTimeCurrGrid).total_seconds()),
                              1, currGrid, currGridTime])
            tempDictLastIncident[currGrid] = currGridTime

        except ValueError:
            raise Exception("value error calculating arrival time difference")

    return events


def getGridSpatialFeaturesAverage(hierObj, startDate, endDate):
    if not os.path.exists(os.getcwd() + "/data/gridIncidentAverage.pickle"):

        hierObj.gridIncidentAverage = {}

        for grid in hierObj.validGrids:
            print grid
            pastEventCounterGrid2Hours = 0
            pastEventCounterGrid1Week = 0
            pastEventCounterGrid1Month = 0

            pastEventCounterNeighbors2Hours = 0
            pastEventCounterNeighbors1Week = 0
            pastEventCounterNeighbors1Month = 0

            counterY, counterX = hierObj.gridToCoord[grid]
            location = hierObj.grids[counterY, counterX]
            # calculate center of the grid from the corner coordinates
            location = (location[0] + location[1]) / 2

            #get for each grid, the average number of events in the last two hours in a) it and b) neighbors
            observationCountHour = 0
            tempStart = startDate
            while tempStart + timedelta(hours=2) <= endDate:
                observationCountHour += 1
                mask = (hierObj.eventTimesCompleteDF['time'] > tempStart) & (
                    hierObj.eventTimesCompleteDF['time'] < tempStart + timedelta(hours=2))
                tempData = hierObj.eventTimesDF.loc[mask]

                tempVal = tempData.values
                for counter in range(len(tempVal)):
                    if abs(location[0] - tempVal[counter][0]) < 3 * hierObj.gridSize / float(2) and abs(
                                    location[1] - tempVal[counter][1]) < 3 * hierObj.gridSize / float(2):
                        pastEventCounterGrid2Hours += 1
                    elif abs(location[0] - tempVal[counter][0]) < 5 * hierObj.gridSize / float(2) and abs(
                                    location[1] - tempVal[counter][1]) < 5 * hierObj.gridSize / float(2):
                        pastEventCounterNeighbors2Hours += 1

                tempStart += timedelta(hours=1)

            # get for each grid, the average number of events in the last week in a) it and b) neighbors
            observationCountWeek = 0
            tempStart = startDate
            while tempStart + timedelta(days=7) <= endDate:
                observationCountWeek += 1
                mask = (hierObj.eventTimesCompleteDF['time'] > tempStart) & (
                    hierObj.eventTimesCompleteDF['time'] < tempStart + timedelta(days=7))
                tempData = hierObj.eventTimesDF.loc[mask]

                tempVal = tempData.values
                for counter in range(len(tempVal)):
                    if abs(location[0] - tempVal[counter][0]) < 3 * hierObj.gridSize / float(2) and abs(
                                    location[1] - tempVal[counter][1]) < 3 * hierObj.gridSize / float(2):
                        pastEventCounterGrid1Week += 1
                    elif abs(location[0] - tempVal[counter][0]) < 5 * hierObj.gridSize / float(2) and abs(
                                    location[1] - tempVal[counter][1]) < 5 * hierObj.gridSize / float(2):
                        pastEventCounterNeighbors1Week += 1

                tempStart += timedelta(days=1)

            # get for each grid, the average number of events in the last month in a) it and b) neighbors
            observationCountMonth = 0
            tempStart = startDate
            while tempStart + timedelta(days=30) <= endDate:
                observationCountMonth += 1
                mask = (hierObj.eventTimesCompleteDF['time'] > tempStart) & (
                    hierObj.eventTimesCompleteDF['time'] < tempStart + timedelta(days=30))
                tempData = hierObj.eventTimesDF.loc[mask]

                tempVal = tempData.values
                for counter in range(len(tempVal)):
                    if abs(location[0] - tempVal[counter][0]) < 3 * hierObj.gridSize / float(2) and abs(
                                    location[1] - tempVal[counter][1]) < 3 * hierObj.gridSize / float(2):
                        pastEventCounterGrid1Month += 1
                    elif abs(location[0] - tempVal[counter][0]) < 5 * hierObj.gridSize / float(2) and abs(
                                    location[1] - tempVal[counter][1]) < 5 * hierObj.gridSize / float(2):
                        pastEventCounterNeighbors1Month += 1

                tempStart += timedelta(days=1)

            hierObj.gridIncidentAverage[grid] = {'gridHour':pastEventCounterGrid2Hours/observationCountHour,
                                                 'gridWeek':pastEventCounterGrid1Week/observationCountWeek,
                                                 'gridMonth':pastEventCounterGrid1Month/observationCountMonth,
                                                 'gridNeighborHour':pastEventCounterNeighbors2Hours/observationCountHour,
                                                 'gridNeighborWeek':pastEventCounterNeighbors1Week/observationCountWeek,
                                                 'gridNeighborMonth':pastEventCounterNeighbors1Month/observationCountMonth}


        print "Created Average Spatial Feature Counts for Marginal Distribution"

        with open(os.getcwd() + "/data/gridIncidentAverage.pickle",'w+') as f:
            pickle.dump(hierObj.gridIncidentAverage,f)
    else:
        with open(os.getcwd() + "/data/gridIncidentAverage.pickle",'r+') as f:
            hierObj.gridIncidentAverage = pickle.load(f)

def getEventDynamicFeatures(inputs, hierObj, purpose, distinctSeason=True,distinctTimeZones=True):
    '''
    Returns the feature set for a given grid
    purpose can be train or predict:
    if train : include time,death etc.
    if predict : only include covariates needed to calculate the scale
    '''
    # create separate survival analysis rows variable : one for each of the grid init sizes
    survAnalysisRows = []
    counterInput = 0
    # print "Total Entries : " + str(len(inputs))
    # have a different result array for each grid init size
    for input in inputs:
        counterInput += 1
        if counterInput % 10000 == 0:
            print counterInput
        if hierObj.debug:
            if counterInput == 2000:
                break
        tempGridNumber = input[2]
        if tempGridNumber in hierObj.validGrids:
            try:
                if purpose=="train" or purpose=="test":
                    interArrival = input[0]
                    censored = input[1]
                    result = [tempGridNumber, interArrival, censored]
                elif purpose=="predict":
                    result = [1]

                time = input[3]
                counterY, counterX = hierObj.gridToCoord[tempGridNumber]
                location = hierObj.grids[counterY, counterX]
                # calculate center of the grid from the corner coordinates
                location = (location[0] + location[1]) / 2


                numRows = hierObj.sheetWeather[str(time.year)].nrows
                month = time.month
                day = time.day
                for counter in range(1, numRows):
                    if int(hierObj.sheetWeather[str(time.year)].cell_value(counter, 0)) == month and int(
                            hierObj.sheetWeather[str(time.year)].cell_value(counter, 1)) == day:
                        weather = [float(hierObj.sheetWeather[str(time.year)].cell_value(counter, 2)),
                                   float(hierObj.sheetWeather[str(time.year)].cell_value(counter, 7))]
                        break
                        # get season
                # when set to true, we use one variable each for season and timeZone with levels, when false, we create
                # a vector of values
                factorR = True
                if factorR and distinctSeason:
                    if time.month in [1, 2, 12]:
                        season = 1
                    elif time.month in [3, 4]:
                        season = 2
                    elif time.month in [5, 6, 7, 8, 9]:
                        season = 3
                    elif time.month in [10, 11]:
                        season = 4

                    weather.append(season)


                if time.weekday() in [4, 5, 6]:
                    weekend = 1
                else:
                    weekend = 0

                result.extend(weather)
                if distinctTimeZones:#only for prediction, by default True for training
                    timeZoneVector = [0] * 5
                    timeZone = getTimeZoneOfDay(time)
                    if timeZone != 5:
                        timeZoneVector[timeZone] = 1
                    result.extend(timeZoneVector)

                result.append(weekend)

                pastEventCounterGrid2Hours = 0
                pastEventCounterGrid1Week = 0
                pastEventCounterGrid1Month = 0

                pastEventCounterNeighbors2Hours = 0
                pastEventCounterNeighbors1Week = 0
                pastEventCounterNeighbors1Month = 0

                EventInGridOrInNeighbour = 0

                # calculate based on dataframe:
                mask = (hierObj.eventTimesCompleteDF['time'] > time - timedelta(seconds=3600 * 24 * 31)) & (
                hierObj.eventTimesCompleteDF['time'] < time)
                tempData = hierObj.eventTimesDF.loc[mask]

                tempVal = tempData.values

                # grid size for past crime should depend on the grid size that we are choosing for police presence.
                for counter in range(len(tempVal)):
                    # if abs(location[0]-pastCrime[counter][0]) < 1*mileToMeter and abs(location[1] - pastCrime[counter][1]) < gridSize/float(2):
                    if abs(location[0] - tempVal[counter][0]) < 3 * hierObj.gridSize / float(2) and abs(
                                    location[1] - tempVal[counter][1]) < 3 * hierObj.gridSize / float(2):
                        EventInGridOrInNeighbour += 1
                        if (time - tempVal[counter][2]).total_seconds() > 0 and abs(
                                (time - tempVal[counter][2]).total_seconds()) < 3600 * 24 * 2:
                            pastEventCounterGrid2Hours += 1
                            # print "past Crime"

                        elif (time - tempVal[counter][2]).total_seconds() > 0 and abs(
                                (time - tempVal[counter][2]).total_seconds()) < 3600 * 24 * 7:
                            pastEventCounterGrid1Week += 1
                            # print "past Crime"

                        elif (time - tempVal[counter][2]).total_seconds() > 0 and abs(
                                (time - tempVal[counter][2]).total_seconds()) < 3600 * 24 * 30:
                            pastEventCounterGrid1Month += 1
                            # print "past Crime"

                    # elif abs(location[0]-pastCrime[counter][0]) < 3*mileToMeter and abs(location[1] - pastCrime[counter][1]) < 3*gridSize/float(2):
                    elif abs(location[0] - tempVal[counter][0]) < 5 * hierObj.gridSize / float(2) and abs(
                                    location[1] - tempVal[counter][1]) < 5 * hierObj.gridSize / float(2):
                        EventInGridOrInNeighbour += 1
                        if (time - tempVal[counter][2]).total_seconds() > 0 and abs(
                                (time - tempVal[counter][2]).total_seconds()) < 3600 * 24 * 2:
                            pastEventCounterNeighbors2Hours += 1
                            # print "past Crime"

                        elif (time - tempVal[counter][2]).total_seconds() > 0 and abs(
                                (time - tempVal[counter][2]).total_seconds()) < 3600 * 24 * 7:
                            pastEventCounterNeighbors1Week += 1
                            # print "past Crime"

                        elif (time - tempVal[counter][2]).total_seconds() > 0 and abs(
                                (time - tempVal[counter][2]).total_seconds()) < 3600 * 24 * 30:
                            pastEventCounterNeighbors1Month += 1
                            # print "past Crime"

                result.extend([pastEventCounterGrid2Hours, pastEventCounterGrid1Week, pastEventCounterGrid1Month, \
                               pastEventCounterNeighbors2Hours, pastEventCounterNeighbors1Week,
                               pastEventCounterNeighbors1Month])

                # result.extend(hierObj.gridStaticDict[tempGridNumber])
                survAnalysisRows.append(result)

            except TypeError as e:
                raise Exception(e)
            # except ValueError as e:
            #     raise Exception(e)
            except IndexError as e:
                raise Exception(e)
    return survAnalysisRows




